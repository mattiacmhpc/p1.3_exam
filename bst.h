#include <memory>//unique ptr
#include <iostream>
#include <vector>


#ifndef __BST__H__
#define __BST__H__


template <typename key_type,typename value_type>
class tree_node //definition of node of the tree
   {
       
   public:
       std::pair<const key_type,value_type> data;//store the key and value of the node
       std::unique_ptr<tree_node> left;//Unique ptr to the left node from this node
       std::unique_ptr<tree_node> right;
       tree_node* up;
       
        
   
       //default ctor
       tree_node() noexcept=default;
    
       //provide key
       key_type get_key()
       {
           return data.first;
       }
     
       
       //custom ctor
       explicit tree_node(const std::pair<const key_type,value_type>& d, tree_node * p):
       data{d},left{},right{},up{p} {};
       //copy ctor (tree)
       explicit tree_node(const std::unique_ptr<tree_node>& ptr):
       data{ptr->data},left{},right{},up{}
       {
           if(ptr->left)
           {
               left=std::make_unique<tree_node>(ptr->left);
               left->up=this;
           }
           if(ptr->right)
           {
               right=std::make_unique<tree_node>(ptr->right);
               right->up =this;
           }
       };
       //custom move ctor
       explicit tree_node(std::pair<const key_type,value_type>&& d, tree_node * p):
       data{std::move(d)},left{},right{},up{p} {};
       
    
   };


template <typename key_type,typename value_type,typename cmp=std::less<key_type> >
class bst //binarysearchtree
{
    cmp compar;
    //node of origin of the tree
    std::unique_ptr<tree_node<key_type,value_type>> root;

    void vector_fill_mid(std::vector<std::pair<const key_type, value_type>> v, int first, int last){
       int mid = (first+last)/2;
       insert(v[mid]);
       if(first >= last) return;
       vector_fill_mid(v, 0, mid-1);
       vector_fill_mid(v, mid+1, last);
     }
public:
    

    cmp get_cmp()
    {
        return compar;
    }
    //default ctor generated by the compiler, no resources
    bst() noexcept = default;
    //move semantic only for smart ptr
    bst(bst&& b) noexcept = default;
    bst& operator=(bst&& b) noexcept = default;
    //copy semantic
    bst(const bst& b) : root{}
    {
        if(b.root) root=std::make_unique<tree_node<key_type,value_type>>(b.root);
    }
    
    bst& operator=(const bst& b)
    {
        root.reset();
        auto temp{b};
        *this = std::move(temp);
        return *this;
    }
    
    template <typename O>
    class __iterator;
    

    using iterator = __iterator<std::pair<const key_type,value_type>>;
    using const_iterator = __iterator<const std::pair<const key_type,value_type>>;
     
     //end iterator
     iterator end() { return iterator{nullptr}; }
     const_iterator end() const { return const_iterator{nullptr}; }
     const_iterator cend() const { return const_iterator{nullptr}; }
     
     //begin iterator
     iterator begin() noexcept
     {
         if(!root) return iterator{nullptr};
         auto temp = root.get();
         while (temp->left) temp= temp->left.get();
         return iterator{temp};
     }
     
     const_iterator begin() const
     {
         if(!root) return const_iterator{nullptr};
         auto temp = root.get();
         while (temp->left) temp= temp->left.get();
         return const_iterator{temp};
     }
     
     const_iterator cbegin() const
     {
         if(!root) return const_iterator{nullptr};
         auto temp = root.get();
         while (temp->left) temp= temp->left.get();
         return const_iterator{temp};
     }
    
    iterator find(const key_type& x)
    {
        auto temp = root.get();
        
        while (temp)
        {
            if (compar(temp->get_key(), x)) { // tmp_k < x
                temp = temp -> right.get();
            }
            else if(compar(x,temp->get_key())){ // x < tmp_k
                temp = temp -> left.get();
            } else { //x=tmp_k
                return iterator{temp};
            }
            
        }
        return end();
    }
    
    const_iterator find(const key_type x) const {return const_iterator{find(x)};}
    
    //insert function
    std::pair<iterator,bool> insert (const std::pair<const key_type,value_type>& x)
    {
        auto temp = root.get();
        
       while(temp)
       {
           if(compar(temp->get_key(),x.first))
           {
               if(temp->right) temp = (temp->right).get();
               else
               {                //verificare se Ã¨ temp o temp->get_up()
                   temp->right.reset(new tree_node<key_type,value_type>(x,temp));
                   return std::make_pair<iterator,bool>(iterator{temp->right.get()},true);
               }
           }
           else if (compar(x.first, temp->get_key()))
           {
               if(temp->left) temp = temp->left.get();
               else
               {
                   temp->left.reset(new tree_node<key_type,value_type>(x,temp));
                   return std::make_pair<iterator,bool>(iterator{temp->left.get()},true);
               }
           }
           else return std::make_pair<iterator,bool>(iterator{temp},false);
       }
        
        root.reset(new tree_node<key_type,value_type>(x,nullptr));
        return std::make_pair<iterator,bool>(iterator{root.get()},true);
    }
    
    std::pair<iterator, bool> insert(std::pair<const key_type,value_type>&& x)
    {
        auto temp = root.get();
        
        while(temp)
        {
            if(compar(temp->get_key(),x.first))
            {
                if(temp->right) temp= temp->right.get();
                else
                {
                    temp->right.reset(new tree_node<key_type,value_type>(std::move(x),temp));
                    return std::make_pair<iterator,bool>(iterator{temp->right.get()},true);
                }
            }
            else if (compar(x.first,temp->get_key()))
            {
                if(temp->left) temp = temp->left.get();
                else
                {
                    temp->left.reset(new tree_node<key_type,value_type>(std::move(x),temp));
                    return std::make_pair<iterator,bool>(iterator{temp->left.get()},true);
                }
            }
            else return std::make_pair<iterator,bool>(iterator{temp},false);
        }

        root.reset(new tree_node<key_type,value_type>(std::move(x),nullptr));
        return std::make_pair<iterator,bool>(iterator{root.get()},true);
    }
    
    template<class... Types>
    std::pair<iterator,bool> emplace(Types&&... args)
    {
        return insert(std::pair<const key_type,value_type>{std::forward<Types>(args)...});
    }
    
    
    template <typename OP>
    value_type& operator[] (OP&& x)
    {
        iterator it=find(x);
        if(it== end() ) it = (emplace(std::forward<OP>(x),value_type{})).first;
        return (*it).second;
    }
    
    friend std::ostream& operator<<(std::ostream& os,const bst& x)
    {
        for(const auto i : x) os << i.first << " ";
        os << std::endl;
        
        return os;
    }
    
    void clear() {root.reset();}
    
 
    
     void balance(){
       if(!root) return;
       std::vector<std::pair<const key_type, value_type>> v;
       for( auto new_pair : *this)
         v.push_back(new_pair);
       clear();
       vector_fill_mid(v, 0, v.size()-1);
     }
    
};


//iterator
template <typename key_type, typename value_type, typename cmp>
template <typename O>
class bst<key_type,value_type,cmp>::__iterator
{
    using node = tree_node<key_type,value_type>;
    node * current;
    cmp compar;
    
public:
    explicit __iterator(node *x) noexcept : current{x} {};
    
    using other_type = O;
    using difference_type = std::ptrdiff_t;
    using iterator_category = std::forward_iterator_tag;
    using reference = other_type&;
    using pointer = other_type*;
    
    reference operator*() const noexcept {return current->data;}
    pointer operator->() const noexcept {return &(*(*this));}
    
    __iterator& operator++() noexcept
    {
        auto temp= current->right.get();
        if (temp)
        {
            while(temp->left) temp = temp -> left.get();
            current = temp;
        }
        else
        {
            temp = current->up;
            while (temp && current == temp->right.get())
            {
                current = temp;
                temp = temp->up;
            }
            current = temp;
        }
        return *this;
    }
    
    
    __iterator operator++(int) noexcept
    {
        __iterator temp{current};
        ++(*this);
        return temp;
    }
    
    friend bool operator==(const __iterator& a, const __iterator& b)
    {
        return a.current == b.current;
    }
    
    friend bool operator!=(const __iterator& a , const __iterator& b)
    {
        return !(a==b);
    }
    
    
    
};


#endif
